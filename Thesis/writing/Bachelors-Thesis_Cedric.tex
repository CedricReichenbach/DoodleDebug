\documentclass[english]{scrartcl}
\pagenumbering{arabic}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{xspace}

% ============================================================
% Markup macros for proof-reading
\usepackage{ifthen}
\usepackage[normalem]{ulem} % for \sout
\usepackage{xcolor}
\newcommand{\ra}{$\rightarrow$}
\newboolean{showedits}
\setboolean{showedits}{false} % toggle to show or hide edits
%\setboolean{showedits}{false} % toggle to show or hide edits
\ifthenelse{\boolean{showedits}}
{
	\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
	\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
	\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
	\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
}{
	\newcommand{\ugh}[1]{#1} % please rephrase
	\newcommand{\ins}[1]{#1} % please insert
	\newcommand{\del}[1]{} % please delete
	\newcommand{\chg}[2]{#2}
}
% ============================================================
% Put edit comments in a really ugly standout display
%\usepackage{ifthen}
\usepackage{amssymb}
\newboolean{showcomments}
\setboolean{showcomments}{true}
%\setboolean{showcomments}{false}
\newcommand{\id}[1]{$-$Id: scgPaper.tex 32478 2010-04-29 09:11:32Z oscar $-$}
\newcommand{\yellowbox}[1]{\fcolorbox{gray}{yellow}{\bfseries\sffamily\scriptsize#1}}
\newcommand{\triangles}[1]{{\sf\small$\blacktriangleright$\textit{#1}$\blacktriangleleft$}}
\ifthenelse{\boolean{showcomments}}
%{\newcommand{\nb}[2]{{\yellowbox{#1}\triangles{#2}}}
{\newcommand{\nbc}[3]{
 {\colorbox{#3}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
 {\textcolor{#3}{\sf\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}}}
 \newcommand{\version}{\emph{\scriptsize\id}}}
{\newcommand{\nbc}[3]{}
 \renewcommand{\ugh}[1]{#1} % please rephrase
 \renewcommand{\ins}[1]{#1} % please insert
 \renewcommand{\del}[1]{} % please delete
 \renewcommand{\chg}[2]{#2} % please change
 \newcommand{\version}{}}
\newcommand{\nb}[2]{\nbc{#1}{#2}{orange}}
\newcommand{\here}{\yellowbox{$\Rightarrow$ CONTINUE HERE $\Leftarrow$}}

\newcommand\rev[2]{\nb{TODO (rev #1)}{#2}} % reviewer comments
\newcommand\fix[1]{\nb{FIX}{#1}}
\newcommand\todo[1]{\nb{TO DO}{#1}}
\newcommand\meta[1]{\nbc{META}{#1}{purple}}
\newcommand\jr[1]{\nbc{JR}{#1}{orange}}
\newcommand\nes[1]{\nbc{nes}{#1}{blue}}
\newcommand\on[1]{\nbc{ON}{#1}{red}} % add more author macros here
\newcommand\ewe[1]{\nbc{EWE}{#1}{olive}} % add more author

% ============================================================

\newcommand{\DD}{Dood\-le\-De\-bug\xspace}
\newcommand{\Doodle}{\texttt{Doo.\-dle}\xspace}
\newcommand{\println}{\texttt{Sys\-tem.\-out.\-println}\xspace}

% ============================================================

\begin{document}
\title{DoodleDebug}
\subtitle{A shot-gun marriage between System.out.println and object inspectors}
\maketitle

\begin{abstract}
\meta{Only copied for now.}
Developers need effective ways to inspect and explore the run-time state of programs they are developing and debugging.  Modern debuggers and object inspectors are powerful tools, but they can only be used to explore specific points in the execution where breakpoints have been set. As a result, developers often resort to inserting ``print statements'' in code to log the state at multiple points in the execution. Print statements, however are a `poor man's debugger'', since their output is static and cannot be further explored.
We propose to combine the simplicity of print statements with the graphical sophistication and interaction of modern debugging tools.
\DD is a simple API modeled loosely after Java's \println. Objects that are ``printed'' generate graphical views that can be further explored, and can also be used to navigate back to source code in the IDE.
We introduce \DD and present the results of a usability study that shows that \DD can be very effective for common debugging tasks.
\end{abstract}

\section{Introduction}

For understanding and debugging a program, developers rely on tools to track its runtime states during execution.
One method is to insert print statements like \println in Java.
This method is quick and allows its users to compare different states in time of a specific object, represented by a textual output item.
However, this output is static and comes with a couple of conceptual restrictions. On the one hand, the level of detail is hardcoded through the textual representations of objects.
If a developer decides for a simple and clear way of representation, they will need to rewrite their code for any further inspection and re-run the program after every change.
If they initially choose a detailed and verbose object representation, the output will grow and become tedious to read.
Another drawback of textual representation is caused by the simplicity of plain text.
It's one-dimensional and contains no information about graphical features like advanced formatting or colors.

The other half of the two most widely used debugging tools is the family of debuggers.
When utilizing a debugger, a program can be stopped at a specific point of its execution, allowing developers to inspect any detail of this very state.
A clear advantage over textual output is the ability to inspect objects on demand.
Information is only displayed as soon as the user asks for it, nevertheless available without re-running the program.
The drawbacks of debuggers arise from the fact that their inspector is always bound to a specific point in time and therefore makes it impossible to directly compare different states of the same object.

\DD combines the power of the above mentioned tools, erasing the conceptual problems coming with them.
Its output is is generated through an API taking its cue from \println's paradigms.
A developer simply needs to call \Doodle(object) to doodle any object type.
For simple customization of object representations, a class can implement the \texttt{Doodleable} interface which contains 2 methods, \texttt{doodleOn} and \texttt{summarizeOn}.
In contrast to Java's \texttt{toString}, there are two methods, allowing developers to create two levels of detail for representation.
This distinction takes effect in the principle of Semantic Zoom \cite{semantic-zoom}.
Also, they do not generate plain text but draw content on a virtual canvas.

\section{Existing Debugging Tools}

\subsection{Textual Output}

\subsubsection{Best Practice For Textual Output}
For a detailed comprehension of how programmers use textual output for debugging, we wrote a script that searches for such methods in open source project.
It analysed SqueakSource, a hosting service for Smalltalk projects, searching for \texttt{printOn} methods, Smalltalk's equivalent to Java's \println.
\todo{Results}

\subsubsection{Missing Features On Textual Output}

\subsection{Debuggers}

\subsubsection{Drawbacks Of Using A Debugger}


\section{Design}
For the design of \DD's output, we consulted literature to carefully plan the different project cycles.
The most important rule we obeyed was to not mix up design and implementation\cite{?}, which could lead to expensive refactorings or remaining design flaws.	

\subsection{The Sketching Cycle}
One simple and powerful way to evaluate drafted user interfaces is to confront future users with them.
We took pen and paper and sketched many possible renderings for data types or other UI elements that came to our mind.
As soon as we had accumulated a good amount of them, we internally discussed them to initially get rid of those that obviously contained usability problems.
The other ones were presented to programmers we called over and they had to look at some pictures and explain what they intuitively believed to see.
\todo{images: sketeches and person staring at them}
If people failed to understand the correct meaning of a sketch, we either improved problematic parts of it or completely refused it.
After improvements or complete re-designs, sketches were presented to other programmers to avoid influencing through the last session.
Sketches that were eventually perceived correctly by most of the people would be accepted for later implementation.

\subsection{Inspecting Doodled Objects}


\section{Implementation}

\subsection{The Doodleable Interface}

The \texttt{Doodleable} interface features two methods: \texttt{doodleOn(DoodleCanvas)} for a regular representation and \texttt{summarizeOn(DoodleCanvas)} for a simplified and compact version.
Distinguishing between them enables semantic zoom \cite{semantic-zoom} when inspecting doodles.

\subsubsection{The DoodleCanvas}
Instead of creating a string like in \println, both methods receive a \texttt{DoodleCanvas} object for drawing contents on it.
The paradigm behind \texttt{DoodleCanvas} adopts the formatting of text in terms of lines and columns.
A virtual cursor starts at the upper-left corner of the canvas.
Drawn objects align one beside each other until a new line is created, which causes the cursor to jump back to the left which one line height offset.
The second formatting option is to create new columns, moving the cursor to a position on top, to the right of the right-most previous object.
\texttt{DoodleCanvas} therefore has three public methods: \texttt{draw(Object)}, \texttt{newLine()} and \texttt{newColumn()}.

\todo{Image here}

\subsection{Plugins}
There are cases where implementing the \texttt{Doodleable} canvas is not a satisfying option for developers.
If they don't have access to the source code, there is no (clean) way to add an interface.
Also, the \texttt{Doodleable} API only provides rough formatting options.

\subsubsection{Implementing Plugins}
For advanced arrangement or additional features like coloring, \DD includes the option to provide plugins.
They must implement \texttt{RenderingPlugin}, which is most easily done by extending the built-in \texttt{AbstractPlugin}.
Each plugin holds information about the object types it is able to render.
Instead of drawing to a virtual canvas, a plugin receives a html \texttt{Tag} object and renders its own HTML code into this tag.
The principle of semantic zoom is again retained through two different methods for different detail levels.
In addition to HTML code generation, plugins have the option to cleanly provide CSS rules and individually adjust class attributes assigned to object doodles.

\section{User Study}

\subsection{Study Session Setup}

\subsection{Posed Problems}

\subsection{Subjects}

\subsection{Results}


\section{Conclusion}


\section{Acknowledgements}


\end{document}